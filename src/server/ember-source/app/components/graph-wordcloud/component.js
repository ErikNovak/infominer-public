import GraphComponent from '../graph-component/component';
import { observer } from '@ember/object';
// d3 visualizations
import { min, max } from 'd3-array';
import { select } from 'd3-selection';
import { scaleLinear, scaleQuantize } from 'd3-scale';
// used to create the wordcloud
import cloud from 'npm:d3-cloud';

export default GraphComponent.extend({
    // component attributes
    classNames: ['wordcloud'],

    // container size
    padding: 5,

    // wordcloud font size
    maxFontSize: 40,
    minFontSize: 12,
    classSizes: ['small', 'medium', 'large'],

    /**
     *  Array of text to render
     * [ {text: String, weight: Number } ]
     */
    data: [],

    ///////////////////////////////////////////////////////
    // Component Life Cycle
    ///////////////////////////////////////////////////////

    didReceiveAttrs() {
        this._super(...arguments);
        // prepare data
        this.prepareText(this.get('keywords'));
    },


    ///////////////////////////////////////////////////////
    // Helper functions
    ///////////////////////////////////////////////////////

    /**
     * Prepares the data used to generate the wordcloud.
     * @param {Object[]} keywords - Array of `keyword` and `weight` values.
     */
    prepareText(keywords) {
        // get minimum and maximum weights
        let minWeight = min(keywords, (d) => d.weight);
        let maxWeight = max(keywords, (d) => d.weight);
        // get minimum and maximum font size
        let minFontSize = this.get('minFontSize');
        let maxFontSize = this.get('maxFontSize');

        let classSizes = this.get('classSizes');

        // set font size scale
        let fontScale = scaleLinear()
            .domain([minWeight, maxWeight])
            .range([minFontSize, maxFontSize]);

        // set text color class
        let textSizeClass = scaleQuantize()
            .domain([minFontSize, maxFontSize])
            .range(classSizes);

        // get keywords data
        let data = keywords.map(function(d) {
            return {
                text: d.keyword,
                size: minWeight === maxWeight ?
                    maxFontSize : fontScale(d.weight),
                classSize: minWeight === maxWeight ?
                    classSizes[classSizes.length-1] :
                    textSizeClass(fontScale(d.weight))
            };
        });
        this.set('data', data);
    },

    /**
     * Prepares the cloud canvas.
     */
    drawGraph() {
        // get the container size
        let width = this.get('width');
        let height = this.get('height');

        // get keywords data
        let data = this.get('data');

        // prepare wordcloud
        cloud().size([width, height])
            .words(data)
            .padding(this.get('padding'))
            .rotate(0)
            .fontWeight(500)
            .fontSize(function(d) { return d.size; })
            .on('end', this.createWordCloud.bind(this))
            .start();
    },

    /**
     * Draws the wordcloud on the creen.
     * @param {Object[]} words - Array of words generated by `prepareText`.
     */
    createWordCloud(words) {
        // get the container size
        let width = this.get('width');
        let height = this.get('height');

        // remove previous g components
        select(this.element).selectAll('g').remove();

        // create a new wordcloud
        select(this.element)
            .attr('width', width)
            .attr('height', height)
          .append('g')
            .attr('transform', `translate(${width / 2}, ${height / 2})`)
          .selectAll('text')
            .data(words)
          .enter().append('text')
            .style("font-size", function(d) { return d.size + "px"; })
            .attr('class', function (d) { return d.classSize; })
            .attr("text-anchor", "middle")
            .attr("transform", function(d) { return "translate(" + [d.x, d.y] + ")"; })
            .text(function(d) { return d.text; });
    }

});
